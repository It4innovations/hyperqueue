use chrono::Local;
use std::time::{Duration, SystemTime, UNIX_EPOCH};

use ratatui::layout::{Alignment, Constraint};
use ratatui::style::{Color, Modifier, Style};
use ratatui::text::Span;
use ratatui::widgets::{Axis, Block, Borders, Chart, Dataset, GraphType, LegendPosition};

use crate::dashboard::data::{ItemWithTime, TimeRange};
use crate::dashboard::ui::styles::chart_style_deselected;

pub fn get_time_as_secs(time: SystemTime) -> f64 {
    time.duration_since(UNIX_EPOCH).unwrap().as_secs() as f64
}

fn format_time_hms(time: SystemTime) -> String {
    let datetime: chrono::DateTime<Local> = time.into();
    datetime.format("%H:%M:%S").to_string()
}

/// Creates a X axis for a time chart, from a range of time.
pub fn x_axis_time_chart(range: TimeRange) -> Axis<'static> {
    Axis::default()
        .style(Style::default().fg(Color::Gray))
        .bounds([
            get_time_as_secs(range.start()),
            get_time_as_secs(range.end()),
        ])
        .labels(vec![
            format_time_hms(range.start()),
            format_time_hms(range.end()),
        ])
}

/// Crates a Y axis from a minimum and maximum bound, with `step_count` steps.
pub fn y_axis_steps(min: f64, max: f64, step_count: u32) -> Axis<'static> {
    let length = max - min;
    let interval = length / step_count as f64;

    Axis::default()
        .style(Style::default().fg(Color::Gray))
        .bounds([min, max])
        .labels(
            (0..=step_count)
                .map(|step| {
                    let value = step as f64 * interval;
                    let value = value.ceil() as u64;
                    value.to_string()
                })
                .collect::<Vec<_>>(),
        )
        .labels_alignment(Alignment::Right)
}

pub fn create_chart<'a>(datasets: Vec<Dataset<'a>>, title: &'a str, range: TimeRange) -> Chart<'a> {
    Chart::new(datasets)
        .style(chart_style_deselected())
        .legend_position(Some(LegendPosition::TopLeft))
        .hidden_legend_constraints((Constraint::Ratio(1, 1), Constraint::Ratio(1, 1)))
        .block(
            Block::default()
                .title(Span::styled(
                    title,
                    Style::default()
                        .fg(Color::White)
                        .add_modifier(Modifier::BOLD),
                ))
                .borders(Borders::ALL),
        )
        .x_axis(x_axis_time_chart(range))
}

pub fn create_dataset<'a>(items: &'a [(f64, f64)], name: &'a str, color: Color) -> Dataset<'a> {
    Dataset::default()
        .name(name)
        .graph_type(GraphType::Line)
        .style(Style::default().fg(color))
        .data(items)
}

/// Iterator through individual steps within a time range.
pub struct RangeSteps {
    range: TimeRange,
    interval: Duration,
    step: usize,
}

impl RangeSteps {
    pub fn new(range: TimeRange, steps: u32) -> Self {
        let interval = range.end().duration_since(range.start()).unwrap() / steps;
        Self {
            range,
            interval,
            step: 0,
        }
    }
}

impl Iterator for RangeSteps {
    type Item = SystemTime;

    fn next(&mut self) -> Option<Self::Item> {
        let time = self.range.start() + self.interval * self.step as u32;
        if time <= self.range.end() {
            self.step += 1;
            Some(time)
        } else {
            None
        }
    }
}

/// Generate a series of values from timestamps generated by the given
/// `RangeSteps` iterator.
pub fn generate_time_data<F, T>(steps: RangeSteps, f: F) -> Vec<ItemWithTime<T>>
where
    F: Fn(SystemTime) -> T,
{
    steps
        .map(|time| ItemWithTime {
            time,
            item: f(time),
        })
        .collect()
}

/// Generate a vector of f64 tuples that can be used to create a dataset.
pub fn generate_dataset_entries<F, T>(items: &[ItemWithTime<T>], f: F) -> Vec<(f64, f64)>
where
    F: Fn(&T) -> f64,
{
    items
        .iter()
        .map(|item| (get_time_as_secs(item.time), f(&item.item)))
        .collect()
}
